B <- c(runif(1,xlims[1],xlims[2]),runif(1,ylims[1],ylims[2]))
AtoB <- shortestPath(Conductance, A, B, output="SpatialLines")
BtoA <- shortestPath(Conductance, B, A, output="SpatialLines")
plot(r, xlab="x coordinate (m)", ylab="y coordinate (m)",
legend.lab="Altitude (masl)")
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1] - 10, A[2] - 10, "A")
text(B[1] + 10, B[2] + 10, "B")
#Calculating Distances
sP <- cbind(c(-72.20,-72.16, -72.18, -72.15), c(42.515, 42.530, 42.510, 42.520))
points(sP, col="snow", pch=20, cex=.75)
text(x=-72.199, y=42.515, "1", col="black", cex=.5)
text(x=-72.159, y=42.530, "2", col="black", cex=.5)
text(x=-72.179, y=42.510, "3", col="black", cex=.5)
text(x=-72.149, y=42.520, "4", col="black", cex=.5)
costDistance(Conductance, sP)
dist(as.matrix(costDistance(Conductance, sP)))
?dist
?maxValue(costDistance(Conductance, sP))
costDistance(Conductance, sP)
which(mm == max(mm), arr.ind = TRUE)
cd <- costDistance(Conductance, sP)
which(cd == max(mm), arr.ind = TRUE)
which(cd == max(cd), arr.ind = TRUE)
costDistance(Conductance, sP)
cd/which(cd == max(cd), arr.ind = TRUE)
(cd)/(which(cd == max(cd), arr.ind = TRUE))
cd
cd/952.3798
cd/(which(cd == max(cd), arr.ind = TRUE))
cd/max(cd)
Bprob <- cd/max(cd)
Bprob
1/(1+4[1-Bprop])
1-Bprob
m <- 1-Bprob
1/(1+4*m)
Fst <- 1/(1+4*m)
Fst <- 1/(1+4*4*m)
1/(1+4*4*m)
1/(1+4*m)
Fst <- 1/(1+4*m)
rSPDistance(Conductance, sP, sP, theta=1e-12, totalNet = "total")
Fst
Bprob
1/(1+4*m)
m <- 1-Bprob #the probability that individuals will migrate
1-Bprob
m
Fst
diag(Fst) <- 0
Fst
costDistance(Conductance, sP)
?function
?function
?function
hello
GspeciesBC <- function ((path == ""){path <- "../data"}
filename <- ("GspeciesBC_2.5.grd")
paste(path,filename, sep="/")
croppeddata<- paste(path,filename, sep="/"))
GspeciesBC <- function (l = (path == ""){path <- "../data"}
filename <- ("GspeciesBC_2.5.grd")
paste(path,filename, sep="/")
croppeddata<- paste(path,filename, sep="/"))
function(if (path == ""){path <- "../data"}
filename <- ("GspeciesBC_2.5.grd")
paste(path,filename, sep="/")
croppeddata<- paste(path,filename, sep="/")
source("helpers.R")
gclust
gClust()
gClust(gspecies, neClim, N=1)
gspecies
#Anna M Calderon
#Matthew K Lau
#Harvard Forest
#gENM-Data Set Up
#Part 0
#8 July 2016
## Step 0. Set a working directory and File Paths
wd <- '../data'
setwd(wd)
# path <- ("")
# if (path == ""){path <- "../data"}
# filename <- ("GspeciesBC_2.5.grd")
# croppeddata<- paste(path,filename, sep="/")
## Step 1. Installing and loading Packages
require(raster)
library(FedData)
## Step 2. Downloading BioClim Data
neClim <- stack("../data/neClim.grd")
# BClim = getData("worldclim", var="bio", res=2.5, path="")
# GspeciesRange = extent(leftlon, rightlon,lowerlat, upperlat)
# BClim = crop(BClim, GspeciesRange)
# writeRaster(BClim, filename=croppeddata, overwrite=T)
# BClim = brick(croppeddata)
## Step 3. Downloading Elevation Data
## Getting climate change projections
library(maptools)
vepPolygon <- polygon_from_extent(raster::extent(xmin, xmax, ymin, ymax),
proj4string="+proj=longlat +ellps=WGS84 +datum=WGS84")
IDs <- sapply(slot(vepPolygon, "polygons"), function(x) slot(x, "ID"))
df <- data.frame(rep(0, length(IDs)), row.names=IDs)
SPDFxx <- SpatialPolygonsDataFrame(vepPolygon, df)
#tf <- tempfile()
#writePolyShape(SPDFxx, tf)
#getinfo.shape(tf)
library(rgdal)
## shape <- readOGR('../data/neExtent',layer='neExtent')
writeOGR(SPDFxx,dsn='../data/neExtent',layer='neExtent',driver='ESRI Shapefile',overwrite_layer=TRUE)
## Step 4. Downloading Species Presence Data
gspecies <- ''
prespoints <- read.csv('http://harvardforest.fas.harvard.edu/data/p14/hf147/hf147-13-antData_use4R_snappedToClim.csv')
if (gspecies == ''){gspecies <- "aphrud"}
colnames(prespoints) = c("spcode", "lon","lat")
gspecies <- prespoints[grep(gspecies,as.character(prespoints$spcode)),]
gspecies$spcode <- NULL
if (identical(colnames(gspecies),c( "lat", "lon"))){gspecies <- gspecies[,c('lon','lat')]}
if (is.matrix(gspecies) == FALSE){gspecies <- data.matrix(gspecies)}
gClust(gspecies, neClim, N=1)
gClust("gspecies", "neClim", N=1)
gClust('gspecies', 'neClim')
library(gdistance)
library(fossil)
library(igraph)
### Creates a symmetric matrix comprised of
### the sum of the upper and lower triangles.
### MKLau - 06July2016
symSum <- function(x='matrix',zero.diag=TRUE){
if (zero.diag == TRUE){diag(x) <- 0}
sum.lu <- t(x)[lower.tri(x)]  + x[lower.tri(x)]
x[lower.tri(x)] <- sum.lu
x <- t(x)
x[lower.tri(x)] <- sum.lu
if (isSymmetric(x)){x}else{
warning('Output matrix is not symmetirc.')
}
}
###
altDiff <- function(x){x[2] - x[1]}
###
NED.plot <- function(NED){plot(NED, xlab="x coordinate (m)", ylab="y coordinate (m)",
legend.lab="Altitude (masl)")}
p.points <- function(gspecies){points(gspecies, col="black", pch=20, cex=.30)}
###
m <- function(scd){(1-(scd/max(scd)))}
###
### gClust - models genetic clusters based on landscape features using circuit
### theory based landscape resistance. Returns a list of observation matrices
### grouped by the 'genetic' clusters.
### MKLau and ACalderon - Summer 2016
### x = Distribution data for a given organism using lon and lat coordinates.
### y = Environmental
### N = effective population size
gClust <- function(x='distribution',y='environment',N=1){
# Conductance matrix is used to produce
# an initial matrix of "flow" between observations
hd <- transition(y, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd)
adj <- adjacent(y, cells=1:ncell(y), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
cd <- costDistance(Conductance, x)
# Summing over assymmetry
scd <- symSum(cd)
# Re-scaling using basic population
# demography to approximate migration.
# N = effective population size, by
# default this is set to one for mathematical
# convenience. The diagonal is set to zero
# because each observation should be
# genetically identical to itself.
# See Conner & Hartl pg. 84
Fst <- 0.20*(1/(1+4*N*m(scd)))
diag(Fst) <- 0
# Invert Fst so that it is a similarity rather
# than a dissimilarity matrix and find
# the minimally connected graph to focus
# on the most important connections.
Fst.g <- 1-Fst
diag(Fst.g) <- 0
Fst.mg <- dino.mst(Fst.g)
Fst.ig <- graph.adjacency(Fst.mg,weighted=TRUE,mode='undirected')
# Determine clusters using a graph theoretic
# module/cluster detection algorithm.
fg.mP <- fastgreedy.community(Fst.ig)
gclust <- fg.mP$membership
names(gc) <- rownames(Fst.mst)
# Output observations in a format for the
# gENM.
gObs <- split(x,gcl)
gObs <- lapply(gObs,matrix,ncol=2)
for (i in 1:length(gObs)){colnames(gObs[[i]]) <- c("lon","lat")}
return(gObs)
}
gClust(gspecies, neClim$bio1, N=1)
gClust("gspecies"," neClim$bio1", N=1)
gClust(x="gspecies", y="neClim$bio1", N=1)
subs
subs[,c("lon","lat")]
#Anna M Calderon
#Matthew K Lau
#Harvard Forest
#gENM-ENM Modeling
#Part 2
#11 July 2016
## Step 1. Installing and loading Packages
packs<-c("rgbif","mapproj","mapdata","sp","maptools","dismo","rJava","rgdal", "rgeos")
unlist(lapply(packs, require, character.only = TRUE))
## Step 2. Limiting Extent
leftlon <- -73.725
rightlon <- -66.958333333
lowerlat <- 40.995206022
upperlat <- 47.453539355
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gObs$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
x=circles(subs[,c("lon","lat")], d=50000, lonlat=T)
lon
"lon"
subs[,c("lon","lat")]
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gObs$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
#Anna M Calderon
#Matthew K Lau
#Harvard Forest
#gENM-Data Set Up
#Part 0
#8 July 2016
## Step 0. Set a working directory and File Paths
wd <- '../data'
setwd(wd)
# path <- ("")
# if (path == ""){path <- "../data"}
# filename <- ("GspeciesBC_2.5.grd")
# croppeddata<- paste(path,filename, sep="/")
## Step 1. Installing and loading Packages
require(raster)
library(FedData)
## Step 2. Downloading BioClim Data
neClim <- stack("../data/neClim.grd")
# BClim = getData("worldclim", var="bio", res=2.5, path="")
# GspeciesRange = extent(leftlon, rightlon,lowerlat, upperlat)
# BClim = crop(BClim, GspeciesRange)
# writeRaster(BClim, filename=croppeddata, overwrite=T)
# BClim = brick(croppeddata)
## Step 3. Downloading Elevation Data
## Getting climate change projections
library(maptools)
vepPolygon <- polygon_from_extent(raster::extent(xmin, xmax, ymin, ymax),
proj4string="+proj=longlat +ellps=WGS84 +datum=WGS84")
IDs <- sapply(slot(vepPolygon, "polygons"), function(x) slot(x, "ID"))
df <- data.frame(rep(0, length(IDs)), row.names=IDs)
SPDFxx <- SpatialPolygonsDataFrame(vepPolygon, df)
#tf <- tempfile()
#writePolyShape(SPDFxx, tf)
#getinfo.shape(tf)
library(rgdal)
## shape <- readOGR('../data/neExtent',layer='neExtent')
writeOGR(SPDFxx,dsn='../data/neExtent',layer='neExtent',driver='ESRI Shapefile',overwrite_layer=TRUE)
## Step 4. Downloading Species Presence Data
gspecies <- ''
prespoints <- read.csv('http://harvardforest.fas.harvard.edu/data/p14/hf147/hf147-13-antData_use4R_snappedToClim.csv')
if (gspecies == ''){gspecies <- "aphrud"}
colnames(prespoints) = c("spcode", "lon","lat")
gspecies <- prespoints[grep(gspecies,as.character(prespoints$spcode)),]
gspecies$spcode <- NULL
if (identical(colnames(gspecies),c( "lat", "lon"))){gspecies <- gspecies[,c('lon','lat')]}
if (is.matrix(gspecies) == FALSE){gspecies <- data.matrix(gspecies)}
packs<-c("rgbif","mapproj","mapdata","sp","maptools","dismo","rJava","rgdal", "rgeos")
unlist(lapply(packs, require, character.only = TRUE))
## Step 2. Limiting Extent
leftlon <- -73.725
rightlon <- -66.958333333
lowerlat <- 40.995206022
upperlat <- 47.453539355
########################################################################################
# create sequences of latitude and longitude values to define the grid
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gObs$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
gObs
# Anna M Calderon
# Matthew K Lau
# Harvard Forest
# gENM-Clustering
# Part 1
# 8 July 2016
### x = Distribution data for a given organism using lon and lat coordinates.
### y = Environmental
### N = effective population size
gClust <- function(x='distribution',y='environment',N=1){
# Conductance matrix is used to produce
# an initial matrix of "flow" between observations
hd <- transition(y, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd)
adj <- adjacent(y, cells=1:ncell(y), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
cd <- costDistance(Conductance, x)
# Summing over assymmetry
scd <- symSum(cd)
# Re-scaling using basic population
# demography to approximate migration.
# N = effective population size, by
# default this is set to one for mathematical
# convenience. The diagonal is set to zero
# because each observation should be
# genetically identical to itself.
# See Conner & Hartl pg. 84
Fst <- 0.20*(1/(1+4*N*m(scd)))
diag(Fst) <- 0
# Invert Fst so that it is a similarity rather
# than a dissimilarity matrix and find
# the minimally connected graph to focus
# on the most important connections.
Fst.g <- 1-Fst
diag(Fst.g) <- 0
Fst.mg <- dino.mst(Fst.g)
Fst.ig <- graph.adjacency(Fst.mg,weighted=TRUE,mode='undirected')
# Determine clusters using a graph theoretic
# module/cluster detection algorithm.
fg.mP <- fastgreedy.community(Fst.ig)
gclust <- fg.mP$membership
names(gc) <- rownames(Fst.mst)
# Output observations in a format for the
# gENM.
gObs <- split(x,gcl)
gObs <- lapply(gObs,matrix,ncol=2)
for (i in 1:length(gObs)){colnames(gObs[[i]]) <- c("lon","lat")}
return(gObs)
}
gObs
gClust(x=gObs, y=neClim$bio1, N=1)
gClust(x=gspecies, y=neClim$bio1)
source("helpers.R")
getwd
getwd()
setwd("../src")
source("helpers.R")
gClust(x=gspecies, y=neClim$bio1)
source("helpers.R")
gClust(x=gspecies, y=neClim$bio1)
source("helpers.R")
gClust(x=gspecies, y=neClim$bio1)
gc <- gClust(x=gspecies, y=neClim$bio1)
leftlon <- -73.725
rightlon <- -66.958333333
lowerlat <- 40.995206022
upperlat <- 47.453539355
########################################################################################
# create sequences of latitude and longitude values to define the grid
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gObs$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
gc
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
gc$`1`[,"lat"]
gc$1[,lat]
gc$1[,"lat"]
gc$`1`[,"lat"]
Clust
gObs$`1`[,lat]
gObs$`1`[,"lat"]
gc$`1`[,"lat"]
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
longrid = seq(-73.725,-66.958333333 ,0.05)
latgrid = seq(40.995206022, 47.453539355,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
x=circles(subs[,c("lon","lat")], d=50000, lonlat=T)
?circles
subs[,c("lon","lat")]
subs
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
sample(1:dim(gridsq)[1],1 )
dim(gridsq)[1]
subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
gridsq
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, gc$`1`[,"lat"] > latgrid[j] & gc$`1`[,"lat"] < latgrid[j+1] & gc$`1`[,"lon"] > longrid[i] & gc$`1`[,"lon"] < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
gridsq
?dim
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
x=circles(subs[,c("lon","lat")], d=50000, lonlat=T)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
subs
subs
c()
?c()
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
