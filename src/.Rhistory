#Part 2
#11 July 2016
## Step 1. Installing and loading Packages
packs<-c("rgbif","mapproj","mapdata","sp","maptools","dismo","rJava","rgdal", "rgeos")
unlist(lapply(packs, require, character.only = TRUE))
## Step 2. Limiting Extent
leftlon <- -73.725
rightlon <- -66.958333333
lowerlat <- 40.995206022
upperlat <- 47.453539355
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gObs$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
x=circles(subs[,c("lon","lat")], d=50000, lonlat=T)
lon
"lon"
subs[,c("lon","lat")]
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gObs$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
#Anna M Calderon
#Matthew K Lau
#Harvard Forest
#gENM-Data Set Up
#Part 0
#8 July 2016
## Step 0. Set a working directory and File Paths
wd <- '../data'
setwd(wd)
# path <- ("")
# if (path == ""){path <- "../data"}
# filename <- ("GspeciesBC_2.5.grd")
# croppeddata<- paste(path,filename, sep="/")
## Step 1. Installing and loading Packages
require(raster)
library(FedData)
## Step 2. Downloading BioClim Data
neClim <- stack("../data/neClim.grd")
# BClim = getData("worldclim", var="bio", res=2.5, path="")
# GspeciesRange = extent(leftlon, rightlon,lowerlat, upperlat)
# BClim = crop(BClim, GspeciesRange)
# writeRaster(BClim, filename=croppeddata, overwrite=T)
# BClim = brick(croppeddata)
## Step 3. Downloading Elevation Data
## Getting climate change projections
library(maptools)
vepPolygon <- polygon_from_extent(raster::extent(xmin, xmax, ymin, ymax),
proj4string="+proj=longlat +ellps=WGS84 +datum=WGS84")
IDs <- sapply(slot(vepPolygon, "polygons"), function(x) slot(x, "ID"))
df <- data.frame(rep(0, length(IDs)), row.names=IDs)
SPDFxx <- SpatialPolygonsDataFrame(vepPolygon, df)
#tf <- tempfile()
#writePolyShape(SPDFxx, tf)
#getinfo.shape(tf)
library(rgdal)
## shape <- readOGR('../data/neExtent',layer='neExtent')
writeOGR(SPDFxx,dsn='../data/neExtent',layer='neExtent',driver='ESRI Shapefile',overwrite_layer=TRUE)
## Step 4. Downloading Species Presence Data
gspecies <- ''
prespoints <- read.csv('http://harvardforest.fas.harvard.edu/data/p14/hf147/hf147-13-antData_use4R_snappedToClim.csv')
if (gspecies == ''){gspecies <- "aphrud"}
colnames(prespoints) = c("spcode", "lon","lat")
gspecies <- prespoints[grep(gspecies,as.character(prespoints$spcode)),]
gspecies$spcode <- NULL
if (identical(colnames(gspecies),c( "lat", "lon"))){gspecies <- gspecies[,c('lon','lat')]}
if (is.matrix(gspecies) == FALSE){gspecies <- data.matrix(gspecies)}
packs<-c("rgbif","mapproj","mapdata","sp","maptools","dismo","rJava","rgdal", "rgeos")
unlist(lapply(packs, require, character.only = TRUE))
## Step 2. Limiting Extent
leftlon <- -73.725
rightlon <- -66.958333333
lowerlat <- 40.995206022
upperlat <- 47.453539355
########################################################################################
# create sequences of latitude and longitude values to define the grid
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gObs$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
gObs
# Anna M Calderon
# Matthew K Lau
# Harvard Forest
# gENM-Clustering
# Part 1
# 8 July 2016
### x = Distribution data for a given organism using lon and lat coordinates.
### y = Environmental
### N = effective population size
gClust <- function(x='distribution',y='environment',N=1){
# Conductance matrix is used to produce
# an initial matrix of "flow" between observations
hd <- transition(y, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd)
adj <- adjacent(y, cells=1:ncell(y), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
cd <- costDistance(Conductance, x)
# Summing over assymmetry
scd <- symSum(cd)
# Re-scaling using basic population
# demography to approximate migration.
# N = effective population size, by
# default this is set to one for mathematical
# convenience. The diagonal is set to zero
# because each observation should be
# genetically identical to itself.
# See Conner & Hartl pg. 84
Fst <- 0.20*(1/(1+4*N*m(scd)))
diag(Fst) <- 0
# Invert Fst so that it is a similarity rather
# than a dissimilarity matrix and find
# the minimally connected graph to focus
# on the most important connections.
Fst.g <- 1-Fst
diag(Fst.g) <- 0
Fst.mg <- dino.mst(Fst.g)
Fst.ig <- graph.adjacency(Fst.mg,weighted=TRUE,mode='undirected')
# Determine clusters using a graph theoretic
# module/cluster detection algorithm.
fg.mP <- fastgreedy.community(Fst.ig)
gclust <- fg.mP$membership
names(gc) <- rownames(Fst.mst)
# Output observations in a format for the
# gENM.
gObs <- split(x,gcl)
gObs <- lapply(gObs,matrix,ncol=2)
for (i in 1:length(gObs)){colnames(gObs[[i]]) <- c("lon","lat")}
return(gObs)
}
gObs
gClust(x=gObs, y=neClim$bio1, N=1)
gClust(x=gspecies, y=neClim$bio1)
source("helpers.R")
getwd
getwd()
setwd("../src")
source("helpers.R")
gClust(x=gspecies, y=neClim$bio1)
source("helpers.R")
gClust(x=gspecies, y=neClim$bio1)
source("helpers.R")
gClust(x=gspecies, y=neClim$bio1)
gc <- gClust(x=gspecies, y=neClim$bio1)
leftlon <- -73.725
rightlon <- -66.958333333
lowerlat <- 40.995206022
upperlat <- 47.453539355
########################################################################################
# create sequences of latitude and longitude values to define the grid
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gObs$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
gc
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
gc$`1`[,"lat"]
gc$1[,lat]
gc$1[,"lat"]
gc$`1`[,"lat"]
Clust
gObs$`1`[,lat]
gObs$`1`[,"lat"]
gc$`1`[,"lat"]
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
longrid = seq(leftlon,rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
longrid = seq(-73.725,-66.958333333 ,0.05)
latgrid = seq(40.995206022, 47.453539355,0.05)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
x=circles(subs[,c("lon","lat")], d=50000, lonlat=T)
?circles
subs[,c("lon","lat")]
subs
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
sample(1:dim(gridsq)[1],1 )
dim(gridsq)[1]
subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
gridsq
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, gc$`1`[,"lat"] > latgrid[j] & gc$`1`[,"lat"] < latgrid[j+1] & gc$`1`[,"lon"] > longrid[i] & gc$`1`[,"lon"] < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
gridsq
?dim
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
x=circles(subs[,c("lon","lat")], d=50000, lonlat=T)
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
subs
subs
c()
?c()
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(gc$`1`, "lat" > latgrid[j] & "lat" < latgrid[j+1] & "lon" > longrid[i] & "lon" < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
gcb1
#Anna M Calderon
#Matthew K Lau
#Harvard Forest
#gENM-Data Set Up
#Part 0
#8 July 2016
## Step 0. Set a working directory and File Paths
wd <- '../data'
setwd(wd)
# path <- ("")
# if (path == ""){path <- "../data"}
# filename <- ("GspeciesBC_2.5.grd")
# croppeddata<- paste(path,filename, sep="/")
## Step 1. Installing and loading Packages
require(raster)
library(FedData)
## Step 2. Downloading BioClim Data
neClim <- stack("../data/neClim.grd")
# BClim = getData("worldclim", var="bio", res=2.5, path="")
# GspeciesRange = extent(leftlon, rightlon,lowerlat, upperlat)
# BClim = crop(BClim, GspeciesRange)
# writeRaster(BClim, filename=croppeddata, overwrite=T)
# BClim = brick(croppeddata)
## Step 3. Downloading Elevation Data
## Getting climate change projections
library(maptools)
vepPolygon <- polygon_from_extent(raster::extent(xmin, xmax, ymin, ymax),
proj4string="+proj=longlat +ellps=WGS84 +datum=WGS84")
IDs <- sapply(slot(vepPolygon, "polygons"), function(x) slot(x, "ID"))
df <- data.frame(rep(0, length(IDs)), row.names=IDs)
SPDFxx <- SpatialPolygonsDataFrame(vepPolygon, df)
#tf <- tempfile()
#writePolyShape(SPDFxx, tf)
#getinfo.shape(tf)
library(rgdal)
## shape <- readOGR('../data/neExtent',layer='neExtent')
writeOGR(SPDFxx,dsn='../data/neExtent',layer='neExtent',driver='ESRI Shapefile',overwrite_layer=TRUE)
## Step 4. Downloading Species Presence Data
gspecies <- ''
prespoints <- read.csv('http://harvardforest.fas.harvard.edu/data/p14/hf147/hf147-13-antData_use4R_snappedToClim.csv')
if (gspecies == ''){gspecies <- "aphrud"}
colnames(prespoints) = c("spcode", "lon","lat")
gspecies <- prespoints[grep(gspecies,as.character(prespoints$spcode)),]
gspecies$spcode <- NULL
if (identical(colnames(gspecies),c( "lat", "lon"))){gspecies <- gspecies[,c('lon','lat')]}
if (is.matrix(gspecies) == FALSE){gspecies <- data.matrix(gspecies)}
# Anna M Calderon
# Matthew K Lau
# Harvard Forest
# gENM-Clustering
# Part 1
# 8 July 2016
### x = Distribution data for a given organism using lon and lat coordinates.
### y = Environmental
### N = effective population size
gClust <- function(x='distribution',y='environment',N=1){
# Conductance matrix is used to produce
# an initial matrix of "flow" between observations
hd <- transition(y, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd)
adj <- adjacent(y, cells=1:ncell(y), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
cd <- costDistance(Conductance, x)
# Summing over assymmetry
scd <- symSum(cd)
# Re-scaling using basic population
# demography to approximate migration.
# N = effective population size, by
# default this is set to one for mathematical
# convenience. The diagonal is set to zero
# because each observation should be
# genetically identical to itself.
# See Conner & Hartl pg. 84
Fst <- 0.20*(1/(1+4*N*m(scd)))
diag(Fst) <- 0
# Invert Fst so that it is a similarity rather
# than a dissimilarity matrix and find
# the minimally connected graph to focus
# on the most important connections.
Fst.g <- 1-Fst
diag(Fst.g) <- 0
Fst.mg <- dino.mst(Fst.g)
Fst.ig <- graph.adjacency(Fst.mg,weighted=TRUE,mode='undirected')
# Determine clusters using a graph theoretic
# module/cluster detection algorithm.
fg.mP <- fastgreedy.community(Fst.ig)
gclust <- fg.mP$membership
names(gc) <- rownames(Fst.mst)
# Output observations in a format for the
# gENM.
gObs <- split(x,gcl)
gObs <- lapply(gObs,matrix,ncol=2)
for (i in 1:length(gObs)){colnames(gObs[[i]]) <- c("lon","lat")}
return(gObs)
}
getwd()
sewd("../src/")
setwd("../src/")
source("helpers.R")
gcb1 <- gClust(x=gspecies, y=neClim$bio1)
gcb1$`1`
x=circles(gcb1$`1`, d=50000, lonlat=T)
random <- spsample(x@polygons, 1000, type='random', iter=1000)
circ=circles(gcb1$`1`, d=50000, lonlat=T)
random <- spsample(x@polygons, 1000, type='random', iter=1000)
randompnts = random@coords
gspecies_bc = data.frame(gspecies_bc)
gspecies_bc = extract(neClim, gcb1$`1`)
random_bc = extract(neClim, random)
gspecies_bc = data.frame(gspecies_bc)
randompnts = random@coords
colnames(randompnts) = c("lon","lat")
random_bc = data.frame(cbind(randompnts,random_bc))
length(which(is.na(random_neClim$bio1)))
random_bc = data.frame(cbind(randompnts,random_bc))
random_bc$bio1
length(which(is.na(random_bc$bio1)))
random_bc = random_bc[!is.na(random_bc$bio1), ]
random_bc
randompnts = random@coords
colnames(randompnts) = c("lon","lat")
random_bc = data.frame(cbind(randompnts,random_bc))
randompnts = random@coords
colnames(randompnts) = c("lon","lat")
random_bc = data.frame(cbind(randompnts,random_bc))
gspecies_bc = extract(neClim, gcb1$`1`)
random_bc = extract(neClim, random)
gspecies_bc = data.frame(gspecies_bc)
randompnts = random@coords
colnames(randompnts) = c("lon","lat")
random_bc = data.frame(cbind(randompnts,random_bc))
clust <- gClust(x=gspecies, y=neClim$bio1)
ENM <- function(x="genetic cluster coordinates")
clust <- gClust(x=gspecies, y=neClim$bio1)
clust <- gClust(x=gspecies, y=neClim$bio1)
clust
circ=circles(clust, d=50000, lonlat=T)
circ=circles(clust$`1`, d=50000, lonlat=T)
random <- spsample(x@polygons, 1000, type='random', iter=1000)
circ=circles(clust$`1`, d=50000, lonlat=T)
random <- spsample(x@polygons, 1000, type='random', iter=1000)
gspecies_bc <-  extract(neClim, clust$`1`)
random_bc <-  extract(neClim, random)
typeof(gspecies_bc)
gspecies_bc <-  data.frame(gspecies_bc)
typeof(gspecies_bc)
randompnts  <-  random@coords
typeof(randompnts)
colnames(randompnts) <-  c("lon","lat")
random_bc
typeof(random_bc)
typeof(random)
random_bc$bio1
random_bc
typeof(random_bc)
colnames(random_bc)
length(which(is.na(random_bc$bio1)))
random_bc$bio1
length(which(is.na(random_bc[,"bio1"])))
random_bc <-  data.frame(cbind(randompnts,random_bc))
length(which(is.na(random_bc[,"bio1"])))
typeof(random_bc)
random_bc[,"bio1"]
random_bc  <-  random_bc[!is.na(random_bc[,"bio1"]), ]
random_bc  <-  random_bc[!is.na(random_bc$bio1), ]
length(which(is.na(random_bc$bio1)))
length(which(is.na(random_bc[,"bio1"])))
clust <- gClust(x=gspecies, y=neClim$bio1)
circ=circles(clust$`1`, d=50000, lonlat=T)
random <- spsample(x@polygons, 1000, type='random', iter=1000)
gspecies_bc <-  extract(neClim, clust$`1`)
random_bc <-  extract(neClim, random)
clust <- gClust(x=gspecies, y=neClim$bio1)
circ=circles(clust$`1`, d=50000, lonlat=T)
random <- spsample(x@polygons, 1000, type='random', iter=1000)
x@polygons
random <- spsample(x@polygons, 1000, type='random', iter=1000)
clust_bc <-  extract(neClim, clust$`1`)
typeof(clust_bc)
clust_bc <-  data.frame(clust_bc)
typeof(clust_bc)
typeof(random)
randompnts  <-  random@coords
typeof(randompnts)
typeof(random@coords)
clust_bc <-  extract(neClim, clust$`1`) #matrix
clust_bc
random  <-  random@coords
random_bc <-  data.frame(cbind(random,random_bc))
random_bc
colnames(random_bc)
clust_bc
random
random_bc <-  extract(neClim, random)
random_bc
random_bc <-  data.frame(cbind(random,random_bc))
random_bc
length(which(is.na(random_bc[,random_bc$bio1])))
length(which(is.na(random_bc[,bio1])))
length(which(is.na(random_bc$bio1)))
random_bc <-  data.frame(cbind(random,random_bc))
typeof(random_bc)
length(which(is.na(random_bc$bio1)))
random_bc[["bio1"]]
