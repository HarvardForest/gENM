#adjacent cells have a slope ≠ 0; this f() restricts calculations to adjacent cells
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
## Retrieve a Conductance matrix:DDDDD
Conductance[1:5, 1:5]
image(Conductance[1:5, 1:5]) #I think darker numbers equal highest conductance
#defining two points on the graph
A <- c(2667670, 5479000)
B <- c(2667800, 5479400)
AtoB <- shortestPath(Conductance, A, B, output="SpatialLines")
BtoA <- shortestPath(Conductance, B, A, output="SpatialLines")
plot(r, xlab="x coordinate (m)", ylab="y coordinate (m)",
legend.lab="Altitude (masl)", xlim = c(2667200, 2668000))
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1] - 10, A[2] - 10, "A")
text(B[1] + 10, B[2] + 10, "B")
#Calculating Distances
sP <- cbind(c(2667670,2667800 ), c(5479000,5479400))
costDistance(Conductance, sP)
rSPDistance(Conductance, sP, sP, theta=1e-12, totalNet = "total")
#install.packages("gdistance")
#library("gdistance")
set.seed(13)
r <- raster(ncol=3,nrow=3)
r[] <- 1:ncell(r)
r
plot(r, main="r", xlab="Longitude (degrees)", ylab="Latitude (degrees)")
text(r)
#4. Transition Classes
r[] <- 1
tr1 <- transition(r, transitionFunction=mean, directions=8)
tr1
#Creating an Asymmetric Matrix
r[] <- runif(9)
ncf <- function(x) max(x) - x[1] + x[2]
tr2 <- transition(r, ncf, 4, symm=FALSE)
tr2
#The class dgCMatrix holds an asymmetric matrix.
tr3 <- tr1*tr2
tr3 <- tr1+tr2
tr3 <- tr1*3
tr3 <- sqrt(tr1)
tr3[cbind(1:9, 1:9)] <- tr2[cbind(1:9, 1:9)]
tr3[1:9, 1:9] <- tr2[1:9, 1:9]
tr3[1:5, 1:5]
image(transitionMatrix(tr1))
############  Hiking around Maunga Whau ##############
#First, we read in the altitude data for the volcano.
r <- raster(system.file("external/maungawhau.grd", package="gdistance"))
#finding the slope
altDiff <- function(x){x[2] - x[1]}
hd <- transition(r, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd) # use the geoCorrection function to divide by the distance between cells.
#adjacent cells have a slope ≠ 0; this f() restricts calculations to adjacent cells
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
## Retrieve a Conductance matrix:DDDDD
Conductance[1:3, 1:3]
image(Conductance[1:3, 1:3]) #I think darker numbers equal highest conductance
#defining two points on the graph
A <- c(2667670, 6479000)
B <- c(2667800, 6479400)
AtoB <- shortestPath(Conductance, A, B, output="SpatialLines")
BtoA <- shortestPath(Conductance, B, A, output="SpatialLines")
plot(r, xlab="x coordinate (m)", ylab="y coordinate (m)",
legend.lab="Altitude (masl)", xlim = c(2667200, 2668000))
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1] - 10, A[2] - 10, "A")
text(B[1] + 10, B[2] + 10, "B")
#Calculating Distances
sP <- cbind(c(2667670,2667800 ), c(6479000,6479400))
costDistance(Conductance, sP)
rSPDistance(Conductance, sP, sP, theta=1e-12, totalNet = "total")
################ Geographical Genetics #########################
Europe <- raster(system.file("external/Europe.grd", package="gdistance"))
Europe[is.na(Europe)] <- 0
data(genDist)
data(popCoord)
pC <- as.matrix(popCoord[c("x","y")])
geoDist <- pointDistance(pC, longlat=TRUE)
geoDist <- as.dist(geoDist)
Europe <- aggregate(Europe,3)
tr <- transition(Europe, mean, directions=8)
trC <- geoCorrection(tr, "c", scl=TRUE)
trR <- geoCorrection(tr, "r", scl=TRUE)
cosDist <- costDistance(trC,pC)
resDist <- commuteDistance(trR, pC)
cor(genDist,geoDist)
cor(genDist,cosDist)
cor(genDist,resDist)
origin <- unlist(popCoord[22,c("x","y")])
pI <- pathInc(trC, origin=origin, from=pC,functions=list(overlap))
cor(genDist,pI[[1]])
Conductance
rm(list=ls())
#First, we read in the altitude data for the volcano.
r <- raster(system.file("external/maungawhau.grd", package="gdistance"))
#finding the slope
altDiff <- function(x){x[2] - x[1]}
hd <- transition(r, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd) # use the geoCorrection function to divide by the distance between cells.
#adjacent cells have a slope ≠ 0; this f() restricts calculations to adjacent cells
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
## Retrieve a Conductance matrix:DDDDD
Conductance[1:3, 1:3]
image(Conductance[1:3, 1:3]) #I think darker numbers equal highest conductance
#defining two points on the graph
A <- c(2667670, 6479000)
B <- c(2667800, 6479400)
AtoB <- shortestPath(Conductance, A, B, output="SpatialLines")
BtoA <- shortestPath(Conductance, B, A, output="SpatialLines")
plot(r, xlab="x coordinate (m)", ylab="y coordinate (m)",
legend.lab="Altitude (masl)", xlim = c(2667200, 2668000))
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1] - 10, A[2] - 10, "A")
text(B[1] + 10, B[2] + 10, "B")
Conductance
Conductance[1:87, 1:61]
image(Conductance[1:87, 1:61]) #I think darker numbers equal highest conductance
A <- c(2667670, 6479000)
B <- c(2667800, 6479400)
AtoB <- shortestPath(Conductance, A, B, output="SpatialLines")
BtoA <- shortestPath(Conductance, B, A, output="SpatialLines")
plot(r, xlab="x coordinate (m)", ylab="y coordinate (m)",
legend.lab="Altitude (masl)", xlim = c(2667200, 2668000))
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1] - 10, A[2] - 10, "A")
text(B[1] + 10, B[2] + 10, "B")
sP <- cbind(c(2667670,2667800 ), c(6479000,6479400))
costDistance(Conductance, sP)
rSPDistance(Conductance, sP, sP, theta=1e-12, totalNet = "total")
Conductance[1:3, 1:3]
sP <- cbind(c(2667670,2667800 ), c(6479000,6479400))
costDistance(Conductance, sP)
rSPDistance(Conductance, sP, sP, theta=1e-12, totalNet = "total")
vepPolygon <- polygon_from_extent(raster::extent(672800,740000,4102000,4170000),proj4string="+proj=utm +datum=NAD83 +zone=12")
vepPolygon <- polygon_from_extent(raster::extent(672800,740000,4102000,4170000),proj4string="+proj=utm +datum=NAD83 +zone=12")
NED <- get_ned(template=vepPolygon,label="VEPIIN")
set.seed(123)
r <- raster(NED)
altDiff <- function(x){x[2] - x[1]}
hd <- transition(r, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd)
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
## Retrieve a Conductance matrix:DDDDD
#Conductance[1:3, 1:3]
image(Conductance[1:3, 1:3]) #I think darker numbers equal highest conductance
#defining two points on the graph
A <- c(672800, 4102000)
B <- c(740000, 4170000)
AtoB <- shortestPath(Conductance, A, B, output="SpatialLines")
BtoA <- shortestPath(Conductance, B, A, output="SpatialLines")
plot(r, xlab="x coordinate (m)", ylab="y coordinate (m)",
legend.lab="Altitude (masl)")
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1] - 10, A[2] - 10, "A")
text(B[1] + 10, B[2] + 10, "B")
#Calculating Distances
sP <- cbind(c(,), c(,))
costDistance(Conductance, sP)
rSPDistance(Conductance, sP, sP, theta=1e-12, totalNet = "total")
library(RDataTracker)
ddg.run("gdistance_template.R")
##-ddg-- Fri Jun 24 16:15:42 2016 ------##
library(FedData)
vepPolygon <- polygon_from_extent(raster::extent(672800,740000,4102000,4170000),proj4string="+proj=utm +datum=NAD83 +zone=12")
NED <- get_ned(template=vepPolygon,label="VEPIIN")
set.seed(123)
r <- raster(NED)
altDiff <- function(x){x[2] - x[1]}
hd <- transition(r, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd)
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
speed <- slope
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
library(RDataTracker)
ddg.run("gdistance_template.R")
##-ddg-- Fri Jun 24 16:25:49 2016 ------##
#install.packages("gdistance")
install.packages("FedData")
# library("FedData")
# library("gdistance")
set.seed(123)
r <- raster(ncol=3,nrow=3)
r[] <- 1:ncell(r)
r
plot(r, main="r", xlab="Longitude (degrees)", ylab="Latitude (degrees)")
text(r)
#4. Transition Classes
r[] <- 1
tr1 <- transition(r, transitionFunction=mean, directions=8)
tr1
#Creating an Asymmetric Matrix
r[] <- runif(9)
ncf <- function(x) max(x) - x[1] + x[2]
tr2 <- transition(r, ncf, 4, symm=FALSE)
tr2
#The class dgCMatrix holds an asymmetric matrix.
tr3 <- tr1*tr2
tr3 <- tr1+tr2
tr3 <- tr1*3
tr3 <- sqrt(tr1)
tr3[cbind(1:9, 1:9)] <- tr2[cbind(1:9, 1:9)]
tr3[1:9, 1:9] <- tr2[1:9, 1:9]
tr3[1:5, 1:5]
image(transitionMatrix(tr1))
############  Hiking around Maunga Whau ##############
#First, we read in the altitude data for the volcano.
r <- raster(system.file("external/maungawhau.grd", package="gdistance"))
#finding the slope
# altDiff <- function(x){x[2] - x[1]}
# hd <- transition(r, altDiff, 8, symm=FALSE)
# slope <- geoCorrection(hd) # use the geoCorrection function to divide by the distance between cells.
# #adjacent cells have a slope ≠ 0; this f() restricts calculations to adjacent cells
# adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
# speed <- slope
# speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
# Conductance <- geoCorrection(speed)
## Retrieve a Conductance matrix:DDDDD
Conductance[1:87, 1:61]
image(Conductance[1:87, 1:61]) #I think darker numbers equal highest conductance
#defining two points on the graph
A <- c(2667670, 6479000)
B <- c(2667800, 6479400)
AtoB <- shortestPath(Conductance, A, B, output="SpatialLines")
set.seed(123)
r <- raster(ncol=3,nrow=3)
r[] <- 1:ncell(r)
r
plot(r, main="r", xlab="Longitude (degrees)", ylab="Latitude (degrees)")
text(r)
#4. Transition Classes
r[] <- 1
tr1 <- transition(r, transitionFunction=mean, directions=8)
tr1
#Creating an Asymmetric Matrix
r[] <- runif(9)
ncf <- function(x) max(x) - x[1] + x[2]
tr2 <- transition(r, ncf, 4, symm=FALSE)
tr2
#The class dgCMatrix holds an asymmetric matrix.
tr3 <- tr1*tr2
tr3 <- tr1+tr2
tr3 <- tr1*3
tr3 <- sqrt(tr1)
tr3[cbind(1:9, 1:9)] <- tr2[cbind(1:9, 1:9)]
tr3[1:9, 1:9] <- tr2[1:9, 1:9]
tr3[1:5, 1:5]
image(transitionMatrix(tr1))
############  Hiking around Maunga Whau ##############
#First, we read in the altitude data for the volcano.
r <- raster(system.file("external/maungawhau.grd", package="gdistance"))
#finding the slope
altDiff <- function(x){x[2] - x[1]}
hd <- transition(r, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd) # use the geoCorrection function to divide by the distance between cells.
#adjacent cells have a slope ≠ 0; this f() restricts calculations to adjacent cells
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed)
## Retrieve a Conductance matrix:DDDDD
Conductance[1:87, 1:61]
image(Conductance[1:87, 1:61]) #I think darker numbers equal highest conductance
#defining two points on the graph
A <- c(2667670, 6479000)
B <- c(2667800, 6479400)
?raster
?transition
NED
remove.packages("gdistance", lib="~/Library/R/3.2/library")
remove.packages("FedData", lib="~/Library/R/3.2/library")
rm(list=ls())
NED
library("gdistance")
library(FedData)
vepPolygon <- polygon_from_extent(raster::extent(672800,740000,4102000,4170000),proj4string="+proj=utm +datum=NAD83 +zone=12")
NED <- get_ned(template=vepPolygon,label="VEPIIN")
NED <- projectRaster(NED,crs="+proj=utm +datum=NAD83 +zone=12")
NED
R
r
set.seed(123)
r <- NED
altDiff <- function(x){x[2] - x[1]}
NED
vepPolygon <- polygon_from_extent(raster::extent(672800,732110,4100100,4170000),proj4string="+proj=utm +datum=NAD83 +zone=12")
NED <- get_ned(template=vepPolygon,label="VEPIIN")
NED <- projectRaster(NED,crs="+proj=utm +datum=NAD83 +zone=12")
NED
set.seed(123)
r <- NED
altDiff <- function(x){x[2] - x[1]}
hd <- transition(r, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd)
crs
projectRaster()
?projectRaster()
?polygon_from_extent
proj4string()
?proj4string
proj4string="+proj=utm +datum=NAD83 +zone=12"
?raster::extent
install.packages("~/Downloads/RDataTracker_2.24.tar.gz", repos = NULL, type = "source")
library(RDataTracker)
setwd("~/Desktop/gENM/src")
ddg.run("SDMScriptTemplate.R",load = TRUE)
##-ddg-- Tue Jun 28 12:01:17 2016 ------##
ddg.run("SDMScriptTemplate.R",load = TRUE)
##-ddg-- Tue Jun 28 12:02:20 2016 ------##
source('~/Desktop/gENM/src/SDMScriptTemplate.R')
setwd("~/Desktop/gENM/src")
ddg.run("SDM_template.R", load= TRUE)
##-ddg-- Tue Jun 28 12:04:48 2016 ------##
### ENM using MaxEnt with GBIF and BioClim data
### A. Calderon and M.K. Lau
### 17June2016
### Inputs
## 1. working directory
wd <- '.' # default is the current working directory
rm(list=ls())
wd <- '.' # default is the current working directory
## 2. choose the species
genus <- ''
species <- ''
## 3. Select a window for the range
leftlon <- ''
rightlon <- ''
lowerlat <- ''
upperlat <- ''
## 4. Define filename and file paths
path <- ("") #data folder path
if (path == ""){path <- "../data"}
filename <- ("GspeciesBC_2.5.grd")
paste(path,filename, sep="/")
croppeddata<- paste(path,filename, sep="/")
## 5. Landscape resistance
## 6. Genetic distance
## 7. Genetic clusters
##############################     Setting your work station    #############################
setwd(wd)
packs<-c("rgbif","mapproj","mapdata","sp","maptools","dismo","rJava","rgdal")
## Load package dependencies
if (!require("pacman")){install.packages("pacman")}
library(pacman)
pacman::p_load(packs)
lapply(packs, require, character.only = TRUE)
###################################    SETTING UP YOUR DATA      ##############################
if (leftlon == ''){leftlon <- -99.2}
if (rightlon == ''){rightlon <- -63}
if (lowerlat == ''){lowerlat <- 23.6}
if (upperlat == ''){upperlat <- 45.5}
if (genus == ''){genus <- 'Aphaenogaster';species <- 'picea'}
rawdata <- gbif(genus = genus, species = species)
na.omit(rawdata[,c('lat','lon')])
Gspecies <- na.omit(rawdata[,c('lat','lon')])
data(stateMapEnv)
######################    PLOTTING PRESENCE AND ABSENCE POINTS  ############################
plot(c(leftlon, rightlon), c(lowerlat, upperlat), mar=par("mar"), xlab="longitude",
ylab="latitude", xaxt="n", yaxt="n", type="n", main="Presence and Absence Points")
rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4], col="lightcyan")
map("state", xlim=c(leftlon, rightlon), ylim=c(lowerlat, upperlat), fill=T, col="honeydew", add=T)
# plot the points
points(Gspecies$lon, Gspecies$lat, col="darkolivegreen4", pch=20, cex=0.5)
axis(1,las=1)
axis(2,las=1)
box()
# create sequences of latitude and longitude values to define the grid
longrid = seq(leftlon, rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
# identify points within each grid cell, draw one at random
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(Gspecies, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
x=circles(subs[,c("lon","lat")], d=50000, lonlat=T)
bg = spsample(x@polygons, 1000, type='random', iter=1000)
points(bg,col="khaki4",pch=1,cex=0.3)
################################    HANDLING CLIMATE DATA     #############################
require(raster)
BClim = getData("worldclim", var="bio", res=2.5, path="")
rm(list=ls())
wd <- '/Users/annacalderon/Desktop/gENM/data/' # default is the current working directory
## 2. choose the species
genus <- ''
species <- ''
## 3. Select a window for the range
leftlon <- ''
rightlon <- ''
lowerlat <- ''
upperlat <- ''
## 4. Define filename and file paths
path <- ("") #data folder path
if (path == ""){path <- "../data"}
filename <- ("GspeciesBC_2.5.grd")
paste(path,filename, sep="/")
croppeddata<- paste(path,filename, sep="/")
## 5. Landscape resistance
## 6. Genetic distance
## 7. Genetic clusters
##############################     Setting your work station    #############################
setwd(wd)
packs<-c("rgbif","mapproj","mapdata","sp","maptools","dismo","rJava","rgdal")
## Load package dependencies
if (!require("pacman")){install.packages("pacman")}
library(pacman)
pacman::p_load(packs)
lapply(packs, require, character.only = TRUE)
###################################    SETTING UP YOUR DATA      ##############################
if (leftlon == ''){leftlon <- -99.2}
if (rightlon == ''){rightlon <- -63}
if (lowerlat == ''){lowerlat <- 23.6}
if (upperlat == ''){upperlat <- 45.5}
if (genus == ''){genus <- 'Aphaenogaster';species <- 'picea'}
rawdata <- gbif(genus = genus, species = species)
na.omit(rawdata[,c('lat','lon')])
Gspecies <- na.omit(rawdata[,c('lat','lon')])
data(stateMapEnv)
######################    PLOTTING PRESENCE AND ABSENCE POINTS  ############################
plot(c(leftlon, rightlon), c(lowerlat, upperlat), mar=par("mar"), xlab="longitude",
ylab="latitude", xaxt="n", yaxt="n", type="n", main="Presence and Absence Points")
rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4], col="lightcyan")
map("state", xlim=c(leftlon, rightlon), ylim=c(lowerlat, upperlat), fill=T, col="honeydew", add=T)
# plot the points
points(Gspecies$lon, Gspecies$lat, col="darkolivegreen4", pch=20, cex=0.5)
axis(1,las=1)
axis(2,las=1)
box()
# create sequences of latitude and longitude values to define the grid
longrid = seq(leftlon, rightlon,0.05)
latgrid = seq(lowerlat, upperlat,0.05)
# identify points within each grid cell, draw one at random
subs = c()
for(i in 1:(length(longrid)-1)){
for(j in 1:(length(latgrid)-1)){
gridsq = subset(Gspecies, lat > latgrid[j] & lat < latgrid[j+1] & lon > longrid[i] & lon < longrid[i+1])
if(dim(gridsq)[1]>0){
subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])
}
}
}
dim(subs)
x=circles(subs[,c("lon","lat")], d=50000, lonlat=T)
bg = spsample(x@polygons, 1000, type='random', iter=1000)
points(bg,col="khaki4",pch=1,cex=0.3)
################################    HANDLING CLIMATE DATA     #############################
require(raster)
BClim = getData("worldclim", var="bio", res=2.5, path="")
#crop data
GspeciesRange = extent(leftlon, rightlon,lowerlat, upperlat)
BClim = crop(BClim, GspeciesRange)
writeRaster(BClim, filename=croppeddata, overwrite=T)
BClim = brick(croppeddata)
#################################PULLING BIOCLIM VALUE######################################
##################################????????????????????######################################
Gspecies_bc = extract(BClim, subs[,c("lon","lat")])
bg_bc = extract(BClim, bg)
Gspecies_bc = data.frame(lon=subs$lon, lat=subs$lat, Gspecies_bc)
bgpoints = bg@coords
colnames(bgpoints) = c("lon","lat")
bg_bc = data.frame(cbind(bgpoints,bg_bc))
length(which(is.na(bg_bc$bio1)))
bg_bc = bg_bc[!is.na(bg_bc$bio1), ]
group_p = kfold(Gspecies_bc, 5)
group_a = kfold(bg_bc, 5)
####################################  BUILDIG YOUR SDM  ############################################
test=3
train_p = Gspecies_bc[group_p!=test, c("lon","lat")]
train_a = bg_bc[group_a!=test, c("lon","lat")]
test_p = Gspecies_bc[group_p==test, c("lon","lat")]
test_a = bg_bc[group_a==test, c("lon","lat")]
me = maxent(BClim, p=train_p, a=train_a)
e = evaluate(test_p, test_a, me, BClim)
e
pred_me = predict(me, BClim)
plot(pred_me, 1, cex=0.5, legend=T, mar=par("mar"), xaxt="n", yaxt="n", main="Predicted Species Distribution")
map("state", xlim=c(leftlon,rightlon), ylim=c(lowerlat,upperlat), fill=F, col="black", add=T)
points(bg,col="snow",pch=1,cex=0.2)
points(Gspecies$lon, Gspecies$lat, col="darkgreen", pch=20, cex=0.5)
# add axes
axis(1,las=1)
axis(2,las=1)
box()
#source("/Users/annacalderon/Desktop/gENM/src/RDataTracker.R")
setwd("~/Desktop/gENM/src")
ddg.run("SDM_template.R")
##-ddg-- Tue Jun 28 12:50:56 2016 ------##
source("/Users/annacalderon/Desktop/gENM/src/RDataTracker.R")
ddg.run("/Users/annacalderon/Desktop/gENM/src/SDM_template.R")
##-ddg-- Tue Jun 28 12:53:30 2016 ------##
